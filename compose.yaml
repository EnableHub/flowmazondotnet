services:
  flowmazonfrontend:
    container_name: flowmazonfrontend
    build:
      context: ./flowmazonfrontend
      dockerfile: Dockerfile
      args:
        NEXT_PUBLIC_BACKEND_URL: ${NEXT_PUBLIC_BACKEND_URL}
    restart: always
    ports:
      - 4000:3000
    networks:
      - flowmazon_network

    develop:
      watch:
        - action: rebuild
          path: ./flowmazonfrontend/src

    # Commented out the following
    # dependency as the healthcheck in
    # flowmazonbackend does not work
    # (see comments there)
    #
    # depends_on:
    #   flowmazonbackend:
    #     condition: service_healthy

  # Add more containers below (nginx, postgres, etc.)
  flowmazonbackend:
    container_name: flowmazonbackend
    build:
      context: ./flowmazonbackend
      dockerfile: Dockerfile
    environment:
      ConnectionStrings__FlowmazonDB: ${ConnectionStrings__FlowmazonDB}
      ALLOWED_CORS_ORIGINS: ${ALLOWED_CORS_ORIGINS}
    restart: always
    # Even though port 8080 on which Kestrel listens
    # is `EXPOSE`d in the flowmazonapi's Dockerfile
    # (this was part of the ASP.NET Core
    # Dockerfile generaetd by VS Code, which I extended),
    # The NExt.js app, once served by the Next.js app
    # container (flowmazonfrontend sevice here) runs in
    # a browser on the host machine and access this backend
    # service from there.
    # Hence we need to map port 8080 to a port on the
    # host machine using `ports` key brlow.
    # It also allows us to access it with Postman etc.
    # during local dev testing.
    ports:
      - 5000:8080
    networks:
      - flowmazon_network
    develop:
      watch:
        - action: rebuild
          path: ./flowmazonbackend/flowmazonapi
    depends_on:
      flowmazondb:
        condition: service_healthy
    #
    # This healthcheck doesn't work
    # most probably because the image does
    # not have wget. It also doesnt't seem to
    # habe curl.
    # TO reinstante the check, create a separate
    # Alpine linux container which can probe
    # the ready endpoint on this container as
    # its own healthcheck, then wait on that
    # container for its healthcheck in
    # flowmazonfrontend service
    #
    # healthcheck:
    #   test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://flowmazonbackend:8080/health/ready"]
    #   interval: 10s
    #   timeout: 5s
    #   retries: 5
  flowmazondb:
    container_name: flowmazondb
    build:
      context: ./flowmazonbackend
      dockerfile: Dockerfile.testdb
      args:
        MIGRATIONS_PATH: ${MIGRATIONS_PATH}
        POSTGRES_USER: ${POSTGRES_USER}
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - 6000:5432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - flowmazon_network

# Define a network, which allows containers to communicate
# with each other, by using their container name as a hostname
networks:
  flowmazon_network:
    driver: bridge
