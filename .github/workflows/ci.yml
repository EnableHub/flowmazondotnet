name: CI
# This concurrency block definition ensures that
# only a single instance of this workflow can be
# be running at any given time for a given
# source (i.e. head) branch
concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true
permissions:
  checks: write
  pull-requests: write
on:
  pull_request:
    branches:
      - main
env:
  PR_LABEL: pr${{ github.event.number }}
  # we don;t know what the version number would be when,
  # and if, this pull request is merged to main.
  # so best to use the place holder 0.0.0 that we also
  # use in package.json in NPM packages (which says
  # 0.0.0-semanticrelease in its "version" field;
  # I do the same in .NET csproj file's <version>
  # element also).
  # Of course we want to suffix 0.0.0 with the PR
  # label for the artifacts produced by this workflow
  # which runs on the source branch of a pull request.
  NEW_VERSION: 0.0.0-$PR_LABEL
jobs:
  audit-signatures:
    name: Audit signatures of NPM dependencies
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
      - name: Audit Provenance Attestations and Signatures
        run: |
          npm ci
          npm audit signatures
  create-update-preview-ephemeral-hcp-workspace:
    name: Create or Update Infrastructure for PR's Preview and compute common variables for workflow
    runs-on: ubuntu-24.04
    environment:
      name: Preview
    outputs:
      workspace_name: ${{ steps.compute-vars.outputs.workspace_name }}
      vault_secret_conn_name: ${{ steps.compute-vars.outputs.vault_secret_conn_name }}
      psql_owner_conn_name: ${{ steps.compute-vars.outputs.psql_owner_conn_name }}
      neon_branch_name: ${{ steps.compute-vars.outputs.neon_branch_name }}
      vercel_project_name: ${{ steps.compute-vars.outputs.vercel_project_name }}
      vercel_app_domain: ${{ steps.compute-vars.outputs.vercel_app_domain }}
      grafana_instance_name: ${{ steps.compute-vars.outputs.grafana_instance_name }}
      grafana_instance_url_secret: ${{ steps.compute-vars.outputs.grafana_instance_url_secret }}
      otel_env: ${{ steps.compute-vars.outputs.otel_env }}
      vercel_project_id_secret: ${{ steps.compute-vars.outputs.vercel_project_id_secret }}
    steps:
      - uses: actions/checkout@v4
      - name: Compute common variables for this and later jobs
        id: compute-vars
        run: |
          TF_WORKFPSACE_NAME="preview-${PR_LABEL}" 
          echo "workspace_name=${TF_WORKFPSACE_NAME}" >> $GITHUB_OUTPUT
          echo "TF_WORKFPSACE_NAME=${TF_WORKFPSACE_NAME}" >> $GITHUB_ENV

          VAULT_SECRET_CONN_NAME="${{ vars.VAULT_SECRETNAME_FOR_CONNECTIONSTRING_PREFIX }}${PR_LABEL}"
          echo "vault_secret_conn_name=${VAULT_SECRET_CONN_NAME}" >> $GITHUB_OUTPUT
          echo "VAULT_SECRET_CONN_NAME=${VAULT_SECRET_CONN_NAME}" >> $GITHUB_ENV

          PSQL_OWNER_CONN_NAME="${{ vars.SECRETNAME_FOR_PSQL_OWNER_CONNECTIONSTRING_PREFIX }}${PR_LABEL}"
          echo "psql_owner_conn_name=${PSQL_OWNER_CONN_NAME}" >> $GITHUB_OUTPUT
          echo "PSQL_OWNER_CONN_NAME=${PSQL_OWNER_CONN_NAME}" >> $GITHUB_ENV

          NEON_BRANCH_NAME="${{ vars.NEON_NEW_BRANCH_NAME_PREFIX }}${PR_LABEL}"
          echo "neon_branch_name=${NEON_BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "NEON_BRANCH_NAME=${NEON_BRANCH_NAME}" >> $GITHUB_ENV

          VERCEL_PROJECT_NAME="${{ secrets.VERCEL_PROJECT_NAME_PREFIX }}${PR_LABEL}"
          echo "vercel_project_name=${VERCEL_PROJECT_NAME}" >> $GITHUB_OUTPUT
          echo "VERCEL_PROJECT_NAME=${VERCEL_PROJECT_NAME}" >> $GITHUB_ENV

          VERCEL_APP_DOMAIN="${PR_LABEL}.${{ vars.VERCEL_APP_APEX_DOMAIN_NAME }}"
          echo "vercel_app_domain=${VERCEL_APP_DOMAIN}" >> $GITHUB_OUTPUT
          echo "VERCEL_APP_DOMAIN=${VERCEL_APP_DOMAIN}" >> $GITHUB_ENV

          GRAFANA_INSTANCE_NAME="${{ vars.NEXT_PUBLIC_FARO_SERVICE_NAME_PREFIX }}${PR_LABEL}"
          echo "grafana_instance_name=${GRAFANA_INSTANCE_NAME}" >> $GITHUB_OUTPUT
          echo "GRAFANA_INSTANCE_NAME=${GRAFANA_INSTANCE_NAME}" >> $GITHUB_ENV

          GRAFANA_INSTANCE_URL_SECRET="${{ vars.SECRETNAME_FOR_GRAFANACLOUD_FRONTEND_O11Y_INSTANCE_URL_PREFIX }}${PR_LABEL}"
          echo "grafana_instance_url_secret=${GRAFANA_INSTANCE_URL_SECRET}" >> $GITHUB_OUTPUT
          echo "GRAFANA_INSTANCE_URL_SECRET=${GRAFANA_INSTANCE_URL_SECRET}" >> $GITHUB_ENV

          OTEL_ENV="${{ vars.OTEL_ENVIRONMENT_PREFIX }}${PR_LABEL}"
          echo "otel_env=${OTEL_ENV}" >> $GITHUB_OUTPUT
          echo "OTEL_ENV=${OTEL_ENV}" >> $GITHUB_ENV

          VERCEL_PROJECT_ID_SECRET="${{ vars.SECRETNAME_FOR_VERCEL_PROJECT_ID_PREFIX }}${PR_LABEL}"
          echo "vercel_project_id_secret=${VERCEL_PROJECT_ID_SECRET}" >> $GITHUB_OUTPUT
          echo "VERCEL_PROJECT_ID_SECRET=${VERCEL_PROJECT_ID_SECRET}" >> $GITHUB_ENV

      - name: Create or update preview-ephemeral HCP workspace
        # We don't care if the worksapce already exists as
        # in that case this HCP API Would return an error
        # that we ignore so the step would do nothing.
        # This behaviour is useful if for whatever reason
        # the first time this workflow ran for a PR, the
        # workspace failed to be created. In that we can
        # re-run the workflow and it will try to create
        # the workspace again.
        # HENCE commenting out the line below:
        # if: github.event.action == 'opened'
        env:
          HCP_TF_ORG: ${{ secrets.TF_ORG }}
          HCP_TF_PROJECT: ${{ secrets.TF_PROJECT }}
          HCP_TF_TOKEN: ${{ secrets.TF_API_TOKEN }}
        # It is CRUCIAL to set "execution-mode": "local"
        # in the "data" object in the JSON request body
        # in the cURL to create the TF workspace below.
        #
        # This ensures that terraform apply executes
        # locally even though the state file is maintained
        # in HCP Terraform.
        #
        # Without this, it would run on HCP's runner.
        # There it would fail on terraform apply (but
        # not on terraform init) with the message that modules
        # referenced using `../../modules/<module folder>`
        # could not be read:
        #
        # │ Error: Unreadable module directory
        # │
        # │ Unable to evaluate directory symlink: lstat ../../modules: no such file or
        # │ directory
        # ╵
        # ╷
        # │ Error: Unreadable module directory
        # │
        # │ The directory  could not be read for module "flowmazonfrontend" at
        # │ main.tf:1.
        # ╵
        # Operation failed: failed running terraform init (exit 1)
        # Error: Terraform exited with code 1.
        #
        #
        # You can try to fix that by using git references
        # for the two modules used by the preview-ephemeral
        # root module that corresponds to the workspace:
        #
        # module "flowmazonfrontend" {
        #   source = "git::https://github.com/EnableHub/flowmazondotnet.git//.iac/modules/flowmazonfrontend?ref=main"
        #
        # and
        #
        # module "db_branch" {
        # source = "git::https://github.com/EnableHub/flowmazondotnet.git//.iac/modules/db_branch?ref=main"
        #
        # Then you would get an error if there are more than
        # one modules being referenced via github references
        # in the root module (a single module referenced like
        # this is fine though, which is a bit bafffling):
        #
        # ╷
        # │ Error: Failed to expand subdir globs
        # │
        # │ subdir ".iac/modules/flowmazonfrontend" not found
        #
        # Basically one of the modules cannot be deferennced.
        #
        # I did have the option of copying across the referenced
        # modules into the dir of the root module, then
        # modify the root module to change the references
        # dynamiclly in GitHub Actions workflow. This
        # would likely have worked and would have required
        # only local relative path references because the
        # moule folders would be within the root module's
        # folder.
        #
        # However, I have instead chosen to execute the TF
        # config locally while keeping the state file on
        # HCP Terraform. This is acceptable as the
        # GitHub Actions runner on which terraform apply
        # runs is also a clean machine and the state is
        # still persisted in and managed by HCP Terraform.
        run: |
          TF_WORKFPSACE_NAME="preview-${PR_LABEL}"
          curl -sS \
            -H "Authorization: Bearer ${HCP_TF_TOKEN}" \
            -H "Content-Type: application/vnd.api+json" \
            -X POST \
            -d '{
              "data": {
                "attributes": {
                  "name": "'"${TF_WORKFPSACE_NAME}"'",
                  "auto-apply": false,
                  "execution-mode": "local"
                  
                },
                "type": "workspaces",
                "relationships": {
                  "tag-bindings": {
                    "data": [
                      {
                        "type": "tag-bindings",
                        "attributes": {
                          "key": "preview-ephemeral",
                          "value": ""
                        }
                      }
                    ]
                  },
                  "project": {
                    "data": {
                      "id": "'"${HCP_TF_PROJECT}"'",
                      "type": "projects"
                    }
                  }
                }
              }
            }' \
            "https://app.terraform.io/api/v2/organizations/${HCP_TF_ORG}/workspaces" \
            | tee response.json

          # If workspace already exists, the API will return an error. Ignore if already exists.
          if grep -q '"errors"' response.json; then
            if grep -q 'has already been taken' response.json; then
              echo "Workspace ${TF_WORKFPSACE_NAME} already exists (thath's great!). Continuing to next step..."
            else
              cat response.json
              exit 1
            fi
          fi
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
      - name: Terraform Init
        env:
          TF_WORKSPACE: preview-${{env.PR_LABEL}}
        run: terraform init
        working-directory: .iac/environments/preview-ephemeral
      - name: Terraform Apply
        env:
          TF_WORKSPACE: preview-${{env.PR_LABEL}}
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
          VERCEL_API_TOKEN: ${{ secrets.VERCEL_API_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

        # values of the variables, which are read from secrets and
        # environment variables of Preview environment in the GitHub
        # repo, are mostly the same as those decalared in Preview
        # workspace's Variables in Terraform HCP
        run: |
          terraform apply -auto-approve \
          -var="vault_name=${{ vars.VAULT_NAME }}" \
          -var="vault_resource_group_name=${{ vars.ID_AND_VAULT_RESOURCE_GROUP_NAME }}" \
          -var="vault_secretname_for_connectionstring=${{ env.VAULT_SECRET_CONN_NAME }}" \
          -var="secretname_for_psql_owner_connectionstring=${{ env.PSQL_OWNER_CONN_NAME }}" \
          -var="environmentname_for_secrets_and_variables=Preview" \
          -var="repository_for_secrets_and_variables=flowmazondotnet" \
          -var="neon_project_id=${{ secrets.TF_MANAGED_NEON_PROJECT_ID }}" \
          -var="neon_source_branch_id=${{ secrets.TF_MANAGED_NEON_SOURCE_BRANCH_ID }}" \
          -var="neon_new_branch_name=${{ env.NEON_BRANCH_NAME }}" \
          -var="neon_database_name=${{ vars.NEON_DATABASE_NAME }}" \
          -var="neon_app_role=${{ vars.NEON_APP_ROLE }}" \
          -var="neon_owner_role=${{ vars.NEON_OWNER_ROLE }}" \
          -var="neon_app_role_password=${{ secrets.TF_MANAGED_NEON_APP_ROLE_PASSWORD }}" \
          -var="neon_owner_role_password=${{ secrets.TF_MANAGED_NEON_OWNER_ROLE_PASSWORD }}" \
          -var="vercel_team_id=${{ secrets.VERCEL_TEAM_ID }}" \
          -var="vercel_project_name=${{ env.VERCEL_PROJECT_NAME }}" \
          -var="vercel_app_domain_name=${{ env.VERCEL_APP_DOMAIN }}" \
          -var="vercel_region_for_server_side_execution=${{ vars.VERCEL_REGION_FOR_SERVER_SIDE_EXECUTION }}" \
          -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}" \
          -var="grafanacloud_stack_slug=${{ vars.GRAFANA_STACK_SLUG }}" \
          -var="grafanacloud_frontend_o11y_api_access_token=${{ secrets.GRAFANA_FRONTEND_O11Y_API_ACCESS_TOKEN }}" \
          -var="grafanacloud_frontend_o11y_instance_name=${{ env.GRAFANA_INSTANCE_NAME }}" \
          -var="secretname_for_grafanacloud_frontend_o11y_instance_url=${{ env.GRAFANA_INSTANCE_URL_SECRET }}" \
          -var="env_NEXT_PUBLIC_OTEL_ENVIRONMENT=${{ env.OTEL_ENV }}" \
          -var="env_OTEL_EXPORTER_OTLP_ENDPOINT=${{ vars.ENV_OTEL_EXPORTER_OTLP_ENDPOINT }}" \
          -var="env_OTEL_EXPORTER_OTLP_PROTOCOL=${{ vars.ENV_OTEL_EXPORTER_OTLP_PROTOCOL }}" \
          -var="env_OTEL_EXPORTER_OTLP_HEADERS=${{ secrets.ENV_OTEL_EXPORTER_OTLP_HEADERS }}" \
          -var="secretname_for_vercel_project_id=${{ env.VERCEL_PROJECT_ID_SECRET }}"
        working-directory: .iac/environments/preview-ephemeral

  migrate-db:
    environment:
      name: Preview
    needs: create-update-preview-ephemeral-hcp-workspace
    name: Migrate Database
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install psql client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Run migrations
        env:
          MIGRATIONS_DIR: ./flowmazonbackend/flowmazonapi/MigrationScripts
        run: |
          for f in "$MIGRATIONS_DIR"/*.sql; do
            filename=$(basename "$f")
            echo "Applying migration $filename"
            psql "${{ secrets[needs.create-update-preview-ephemeral-hcp-workspace.outputs.psql_owner_conn_name] }}" -f "$f"
          done
        # Create infrastructure specific to a preview environment

  deploy-backend:
    environment:
      name: Preview
    permissions:
      contents: read # Needed for actions/checkout
      packages: write # Needed to push to GHCR
    needs: [create-update-preview-ephemeral-hcp-workspace, migrate-db]
    name: Deploy API to Azure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Print version to console
        run: |
          echo "Version number of the code artifacts produced for ths pull request-specific Preview environment would be: ${{ env.NEW_VERSION }}"
      # - name: Login to Azure
      #   uses: azure/login@v1
      #   with:
      #     # The referenced secret AZURE_CREDENTIALS contains
      #     # JSON with client id, client secret, tenant id and
      #     # subscription id of the service principal which
      #     # has AcrPush permission on the subscrpition or at least
      #     # on the ACR instance to which it will push in this job
      #     # within the subscription whose subscription id is provided.
      #     #
      #     # Format of the JSON is:
      #     # {
      #     #     "clientId": "<visible on service principal when you create it in portal>",
      #     #     "clientSecret": "<in portal you have to create it after creating the service principal>",
      #     #     "subscriptionId": "<subscription id of the subscription on which you have given AcrPush permission to the service principal>",
      #     #     "tenantId": "<visible on service principal when you create it in portal>"
      #     # }
      #     creds: ${{ secrets.AZURE_CREDENTIALS }}

      # TODO: Create AZURE_CREDENTIALS secret and uncomment above step
      #
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Auto-generated, no setup needed!
      - name: Set lowercase repo owner
        run: |
          echo "REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "FULL_IMAGE_NAME=ghcr.io/${REPO_LOWER}/${{ vars.IMAGE_REPOSITORY }}:${{ env.NEW_VERSION }}" >> $GITHUB_ENV

      - name: Build and Push Docker image
        run: |
          cd ./flowmazonbackend
          docker build -t ${{ env.FULL_IMAGE_NAME }} .
          docker push ${{ env.FULL_IMAGE_NAME }}

      # We need to run terraform apply on prod-api workspace
      # because Terraform resource for ACA app must deploy a container
      # also (otherwise the whole wrorkspace would fail to apply).
      #
      # Therefore we use the workspace to deploy the latest version
      # and later would be doing Blue-Green with it. The ACA resource
      # in the Terraform workspace would pull the container image with
      # the specified version upon terraform apply.
      #
      # As terraform apply runs on HCP Terraform's clean runner machine,
      # we don't need to create a separate job to run terraform apply.
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
        with:
          # cli_config_credentials_hostname parameter default
          # to app.terraform.io which is what we want
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      # - name: Run terraform apply on prod-api workspace
      #   run: |
      #     cd .iac/environments/prod-api
      #     terraform init
      #     terraform apply -auto-approve -var="image_tag=${{ needs.create-release.outputs.newVersion }}"
# for this particular Pull Request (except ACAP app for API,
# which will be created at the same time as deployment due to
# limitations of ACA app's Terraform resource; see
# aca_app module's README)
#
# As the workspace will run on HCP Terraform's runner, I
# wouldn't bother with a job to run terraform apply on
# the workspace preview-ephemeral that is seprate from the
# code to run db migrations (AT LEAST NOT FOR NOW)
