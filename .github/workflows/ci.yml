name: CI
# This concurrency block definition ensures that
# only a single instance of this workflow can be
# be running at any given time for a given
# source (i.e. head) branch
concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true
permissions:
  checks: write
  pull-requests: write
on:
  pull_request:
    branches:
      - main

jobs:
  audit-signatures:
    name: Audit signatures of NPM dependencies
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
      - name: Audit Provenance Attestations and Signatures
        run: |
          npm ci
          npm audit signatures
  create-update-preview-infrastructure:
    name: Create or Update Infrastructure for PR's Preview environment
    runs-on: ubuntu-24.04
    environment:
      name: Preview
    steps:
      - uses: actions/checkout@v4
      - name: Create PR Identifier
        id: pr_id
        run: echo "PR_LABEL=pr${{ github.event.number }}" >> $GITHUB_ENV
      - name: Create HCP Terraform Workspace for PR
        # We don't care if the worksapce already exists as
        # in that case this HCP API Would return an error
        # that we ignore so the step would do nothing.
        # This behaviour is useful if for whatever reason
        # the first time this workflow ran for a PR, the
        # workspace failed to be created. In that we can
        # re-run the workflow and it will try to create
        # the workspace again.
        # HENCE commenting out the line below:
        # if: github.event.action == 'opened'
        env:
          HCP_TF_ORG: ${{ secrets.TF_ORG }}
          HCP_TF_PROJECT: ${{ secrets.TF_PROJECT }}
          HCP_TF_TOKEN: ${{ secrets.TF_API_TOKEN }}
        # It is CRUCIAL to set "execution-mode": "local"
        # in the "data" object in the JSON request body
        # in the cURL to create the TF workspace below.
        #
        # This ensures that terraform apply executes
        # locally even though the state file is maintained
        # in HCP Terraform.
        #
        # Without this, it would run on HCP's runner.
        # There it would fail on terraform apply (but
        # not on terraform init) with the message that modules
        # referenced using `../../modules/<module folder>`
        # could not be read:
        #
        # │ Error: Unreadable module directory
        # │
        # │ Unable to evaluate directory symlink: lstat ../../modules: no such file or
        # │ directory
        # ╵
        # ╷
        # │ Error: Unreadable module directory
        # │
        # │ The directory  could not be read for module "flowmazonfrontend" at
        # │ main.tf:1.
        # ╵
        # Operation failed: failed running terraform init (exit 1)
        # Error: Terraform exited with code 1.
        #
        #
        # You can try to fix that by using git references
        # for the two modules used by the preview-ephemeral
        # root module that corresponds to the workspace:
        #
        # module "flowmazonfrontend" {
        #   source = "git::https://github.com/EnableHub/flowmazondotnet.git//.iac/modules/flowmazonfrontend?ref=main"
        #
        # and
        #
        # module "db_branch" {
        # source = "git::https://github.com/EnableHub/flowmazondotnet.git//.iac/modules/db_branch?ref=main"
        #
        # Then you would get an error if there are more than
        # one modules being referenced via github references
        # in the root module (a single module referenced like
        # this is fine though, which is a bit bafffling):
        #
        # ╷
        # │ Error: Failed to expand subdir globs
        # │
        # │ subdir ".iac/modules/flowmazonfrontend" not found
        #
        # Basically one of the modules cannot be deferennced.
        #
        # I did have the option of copying across the referenced
        # modules into the dir of the root module, then
        # modify the root module to change the references
        # dynamiclly in GitHub Actions workflow. This
        # would likely have worked and would have required
        # only local relative path references because the
        # moule folders would be within the root module's
        # folder.
        #
        # However, I have instead chosen to execute the TF
        # config locally while keeping the state file on
        # HCP Terraform. This is acceptable as the
        # GitHub Actions runner on which terraform apply
        # runs is also a clean machine and the state is
        # still persisted in and managed by HCP Terraform.
        run: |
          WORKSPACE_NAME="preview-${PR_LABEL}"
          curl -sS \
            -H "Authorization: Bearer ${HCP_TF_TOKEN}" \
            -H "Content-Type: application/vnd.api+json" \
            -X POST \
            -d '{
              "data": {
                "attributes": {
                  "name": "'"${WORKSPACE_NAME}"'",
                  "auto-apply": false,
                  "execution-mode": "local"
                  
                },
                "type": "workspaces",
                "relationships": {
                  "tag-bindings": {
                    "data": [
                      {
                        "type": "tag-bindings",
                        "attributes": {
                          "key": "preview-ephemeral",
                          "value": ""
                        }
                      }
                    ]
                  },
                  "project": {
                    "data": {
                      "id": "'"${HCP_TF_PROJECT}"'",
                      "type": "projects"
                    }
                  }
                }
              }
            }' \
            "https://app.terraform.io/api/v2/organizations/${HCP_TF_ORG}/workspaces" \
            | tee response.json

          # If workspace already exists, the API will return an error. Ignore if already exists.
          if grep -q '"errors"' response.json; then
            if grep -q 'has already been taken' response.json; then
              echo "Workspace ${WORKSPACE_NAME} already exists. Continuing."
            else
              cat response.json
              exit 1
            fi
          fi
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
      - name: Terraform Init
        env:
          TF_WORKSPACE: preview-${{env.PR_LABEL}}
        run: terraform init
        working-directory: .iac/environments/preview-ephemeral
      - name: Terraform Apply
        env:
          TF_WORKSPACE: preview-${{env.PR_LABEL}}
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
          VERCEL_API_TOKEN: ${{ secrets.VERCEL_API_TOKEN }}

        # values of the variables, which are read from secrets and
        # environment variables of Preview environment in the GitHub
        # repo, are mostly the same as those decalared in Preview
        # workspace's Variables in Terraform HCP.
        run: |
          terraform apply -auto-approve \
          -var="vault_name=${{ vars.VAULT_NAME }}" \
          -var="vault_resource_group_name=${{ vars.ID_AND_VAULT_RESOURCE_GROUP_NAME }}" \
          -var="vault_secretname_for_connectionstring=${{ vars.VAULT_SECRETNAME_FOR_CONNECTIONSTRING_PREFIX }}${{env.PR_LABEL}}" \
          -var="secretname_for_psql_owner_connectionstring=${{ vars.SECRETNAME_FOR_PSQL_OWNER_CONNECTIONSTRING_PREFIX }}${{env.PR_LABEL}}" \
          -var="environmentname_for_secrets_and_variables=Preview" \
          -var="repository_for_secrets_and_variables=flowmazondotnet" \
          -var="neon_project_id=${{ secrets.TF_MANAGED_NEON_PROJECT_ID }}" \
          -var="neon_source_branch_id=${{ secrets.TF_MANAGED_NEON_SOURCE_BRANCH_ID }}" \
          -var="neon_new_branch_name=${{ vars.NEON_NEW_BRANCH_NAME_PREFIX }}${{env.PR_LABEL}}" \
          -var="neon_database_name=${{ vars.NEON_DATABASE_NAME }}" \
          -var="neon_app_role=${{ vars.NEON_APP_ROLE_PREFIX }}" \
          -var="neon_owner_role=${{ vars.NEON_OWNER_ROLE_PREFIX }}" \
          -var="neon_app_role_password=${{ secrets.TF_MANAGED_NEON_APP_ROLE_PASSWORD }}" \
          -var="neon_owner_role_password=${{ secrets.TF_MANAGED_NEON_OWNER_ROLE_PASSWORD }}" \
          -var="vercel_team_id=${{ secrets.VERCEL_TEAM_ID }}" \
          -var="vercel_project_name=${{ secrets.VERCEL_PROJECT_NAME_PREFIX }}${{env.PR_LABEL}}" \
          -var="vercel_app_domain_name=${{env.PR_LABEL}}.${{ vars.VERCEL_APP_APEX_DOMAIN_NAME }}" \
          -var="vercel_region_for_server_side_execution=${{ vars.VERCEL_REGION_FOR_SERVER_SIDE_EXECUTION }}" \
          -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}" \
          -var="grafanacloud_stack_slug=${{ vars.GRAFANA_STACK_SLUG }}" \
          -var="grafanacloud_frontend_o11y_api_access_token=${{ secrets.GRAFANA_FRONTEND_O11Y_API_ACCESS_TOKEN }}" \
          -var="grafanacloud_frontend_o11y_instance_name=${{ vars.NEXT_PUBLIC_FARO_SERVICE_NAME_PREFIX }}${{env.PR_LABEL}}" \
          -var="secretname_for_grafanacloud_frontend_o11y_instance_url=${{ vars.SECRETNAME_FOR_GRAFANACLOUD_FRONTEND_O11Y_INSTANCE_URL_PREFIX }}${{env.PR_LABEL}}" \
          -var="env_NEXT_PUBLIC_OTEL_ENVIRONMENT=${{ vars.OTEL_ENVIRONMENT_PREFIX }}${{env.PR_LABEL}}" \
          -var="env_OTEL_EXPORTER_OTLP_ENDPOINT=${{ vars.ENV_OTEL_EXPORTER_OTLP_ENDPOINT }}" \
          -var="env_OTEL_EXPORTER_OTLP_PROTOCOL=${{ vars.ENV_OTEL_EXPORTER_OTLP_PROTOCOL }}" \
          -var="env_OTEL_EXPORTER_OTLP_HEADERS=${{ secrets.ENV_OTEL_EXPORTER_OTLP_HEADERS }}" \
          -var="secretname_for_vercel_project_id=${{ vars.SECRETNAME_FOR_VERCEL_PROJECT_ID_PREFIX }}${{env.PR_LABEL}}"
        working-directory: .iac/environments/preview-ephemeral
# Create infrastructure specific to a preview environment
# for this particular Pull Request (except ACAP app for API,
# which will be created at the same time as deployment due to
# limitations of ACA app's Terraform resource; see
# aca_app module's README)
#
# As the workspace will run on HCP Terraform's runner, I
# wouldn't bother with a job to run terraform apply on
# the workspace preview-ephemeral that is seprate from the
# code to run db migrations (AT LEAST NOT FOR NOW)
