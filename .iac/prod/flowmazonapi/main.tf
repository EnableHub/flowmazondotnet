data "azurerm_resource_group" "supporting" {
  name = var.supporting_resource_group_name

}

data "azurerm_user_assigned_identity" "app" {
  name                = var.flowmazon_api_managed_identity
  resource_group_name = data.azurerm_resource_group.supporting.name
}

data "azurerm_key_vault" "app" {
  name                = var.app_key_vault_name
  resource_group_name = data.azurerm_resource_group.supporting.name
}

data "azurerm_key_vault_secret" "connstr_for_app" {
  name         = local.key_vault_secretname_connectionstring_for_api
  key_vault_id = data.azurerm_key_vault.app.id
}

data "azurerm_container_registry" "app" {
  name                = var.acr_name
  resource_group_name = data.azurerm_resource_group.supporting.name
}


resource "azurerm_resource_group" "app" {
  name     = var.resource_group_name
  location = var.resource_group_location
}

resource "azurerm_container_app_environment" "app" {
  name                = var.app-environment-name
  location            = azurerm_resource_group.app.location
  resource_group_name = azurerm_resource_group.app.name

}

resource "azurerm_container_app" "app" {

  name                         = var.app-name
  container_app_environment_id = azurerm_container_app_environment.app.id
  resource_group_name          = azurerm_resource_group.app.name
  revision_mode                = "Multiple"

  ingress {
    external_enabled           = true
    allow_insecure_connections = false
    target_port                = var.app-container-port
    client_certificate_mode    = "require"

    dynamic "ip_security_restriction" {
      for_each = local.cloudflare_ips

      content {
        # want to generate a unique name for the 
        # ip range. Better practice with dynamically
        # generated blocks to do this than to 
        # assign index 1...n that we could have
        # done with count instead of for-each
        # as we have done in this dynamic block
        name             = "Allow-Cloudflare-${replace(replace(replace(ip_security_restriction.value, ".", "-"), ":", "--"), "/", "_")}"
        description      = "One of the CloudFlare's outbound IP ranges. Part of a fairly stable set."
        ip_address_range = ip_security_restriction.value
        action           = "Allow"
      }
    }

    traffic_weight {
      latest_revision = true
      percentage      = 100
    }

    # Note this ingress would need to have a custom domain binding
    # but we only add it (see use of azapi resources below to do 
    # that) once DNS records (CNAME and TXT) have been created
    # at CloudFlare and have propagated.
    # If we do it now we would get an error.
    #
    # I have verified that once the custom domain has been created,
    # subsequent `terraform apply` operations DO NOT detect
    # the addition of custom domain to this ingress as drift and
    # try to deleted it. So we're ok.
  }
  registry {
    server   = data.azurerm_container_registry.app.login_server
    identity = data.azurerm_user_assigned_identity.app.id
  }

  secret {
    name                = local.key_vault_secretname_connectionstring_for_api
    identity            = data.azurerm_user_assigned_identity.app.id
    key_vault_secret_id = data.azurerm_key_vault_secret.connstr_for_app.id
  }

  identity {
    # it is possible for a service to have both. I am giving it 
    # both.
    # This is because while we need the UserAssigned identity to 
    # let the app access the key vault and ACR etc, the 
    # automatically created and assigned system-assigned identity
    # of the app may be used in authN/authZ with ACA app environment
    # which we have created in a way that its settings would be 
    # autogenerated and would not be changeable after creation.
    type         = "SystemAssigned, UserAssigned"
    identity_ids = [data.azurerm_user_assigned_identity.app.id]

  }

  template {
    container {
      name   = var.app_container_name
      image  = "${data.azurerm_container_registry.app.login_server}/${local.image_repository_name}:${var.version_to_deploy}"
      cpu    = 0.5
      memory = "1.0Gi"
      env {
        name  = local.allowed_cors_origins_env_var_name
        value = var.allowed_cors_origins_for_api
      }
      env {
        name = local.connection_string_env_var_name
        # We don't want to set it from the value of the secret
        # read from key vault (the account executing this terraform
        # config may not even have the permission to do that).value
        #
        # If we did that, the value would be visible in 
        # Environment Variables section of the app in plain text
        #
        # Therefore we simply provide the name of the secret
        # we want the value to be retrieved from.
        #
        # For this to work, we need to reference the secret
        # in a secret object in the app object (done above),
        # which in turn requries a reference to a
        # azurerm_key_vault_secret data source and for that a
        # azurerm_key_vault data source.
        secret_name = local.key_vault_secretname_connectionstring_for_api
      }

      liveness_probe {
        transport = "HTTP"
        port      = var.app-container-port
        path      = "/health/live"
      }

      readiness_probe {
        transport = "HTTP"
        port      = var.app-container-port
        path      = "/health/ready"
      }

      # because of the way liveness probe is implemented in 
      # the ASP.NET Core API, the liveness probe only
      # responds with Healthy and 2xx if 
      # startup has completed. So we are using it as
      # startup_probe also
      startup_probe {
        transport = "HTTP"
        port      = var.app-container-port
        path      = "/health/live"
      }

    }
  }
}

# Create DNS settings in CloudFlare

# PREREQUISITE: CloudFlare's namesrevers should already been rwgistered 
# with the Domain Name Registrar you bought the domain name from.
# This would have created a Zone in CLoudFlare for your apex domain
# e.g. `efast.uk`

# returns cloudflare's ip ranges so we can add them to ingress allow rules
# in ACA app
data "cloudflare_ip_ranges" "cloudflare" {}

locals {

  # Create a set of Cloudflare IPv4 IPs which we 
  # will put in the allow list of the container app's ingress
  cloudflare_ips = toset(data.cloudflare_ip_ranges.cloudflare.ipv4_cidrs)

  subdomain  = split(".", var.app_domain_name)[0]                              # e.g., 'api' for 'api.efast.uk'
  apexdomain = trimprefix(var.app_domain_name, format("%s.", local.subdomain)) # e.g., 'efast.uk'

  # this is what we would create a TXT record with for the app's domain name 
  custom_domain_verification_id = azurerm_container_app.app.custom_domain_verification_id

}

# To map the API's domain name to your ACA app, we need to create
# a CNAME record and a TXT record. This is normally done for the
# subdomain part of the app's domain name (for example create a 
# CNAME record for `api` and TXT record for `asuid.api` where the
# domain name of the app is api.efast.uk).
#
# HOWEVER, with CLoudFlare's Terraform resources, you have to
# provide the full domain name (FQDN, e.g. api.efast.uk). If 
# you only provider the prefix then it works on first apply but
# on every subsequent apply, perhaps because you made a change
# to some other resource, the cloudflare_dns_record resource
# would say there is a change and it has to change 
# the current name in the actual CloudFlare DNS record, which
# would be `api.efast.uk` for CNAME record and `asuid.api.efast.uk
# for TXT record, back to `api` and `asuid.api` respectively.
resource "cloudflare_dns_record" "app_cname" {

  zone_id = var.cloudflare_zone_id
  name    = var.app_domain_name

  # this should be the target FQDN without the `https://` prefix,
  # which is how ingress's fqdn property returns it
  content = azurerm_container_app.app.ingress[0].fqdn
  type    = "CNAME"
  ttl     = 1 # 1 means TTL is automatically set by CloudFlare


  # We need to set proxied=false because if it is on, managed
  # certificate verification would fail because it would not
  # be able to  verify the CNAME/TXT records with CloudFlare.
  #
  # As soon as managed certificate creation has 
  # completed, and the cert has been asssigned to 
  # a custom domain binding on the ingress of the app,
  # we would turn it on with a provisioner-like
  # resource that calls CloudFlare's REST API to
  # set proxied to true.
  #
  # This is safe to do as we have already restricted
  # traffic only to CloudFalre IP addresses.
  # We are leaving it off for a blip.
  proxied = false
  lifecycle {
    ignore_changes = [proxied]
  }

}

resource "cloudflare_dns_record" "app_txt" {
  zone_id = var.cloudflare_zone_id
  name    = format("%s.%s", "asuid", var.app_domain_name)
  # I think, but am not sure, that the content of TXT record 
  # must be contained within quotes. It works anyway.
  content = format("\"%s\"", local.custom_domain_verification_id)
  type    = "TXT"
  ttl     = 1 # 1 means TTL is automatically set by CloudFlare
}

# ENABLE mTLS (mutual TLS)
#######################################################################
# tls_client_auth setting on the zone (beware it applies to whole zone)
# means CloudFlare would present the public key of its own certificate 
# to the ACA app when relaying proxied traffic to it.
# The ACA app is set up to require a certificate from the caller.
# This is just an additional security measure on top  of the 
# TLS certificate that the ACA app itself has (for normal TLS)
# and the fact that we have restricted the ingress to accept
# traffic only from CloudFlare's IP addresses.
resource "cloudflare_zone_setting" "app_apex_domain" {
  zone_id    = var.cloudflare_zone_id
  setting_id = "tls_client_auth"
  value      = "on"
}

# bits below from this Gist:
# https://gist.github.com/fdelu/25f4eee056633abc03dc87b4a7e7704b

# First we wait for the DNS records to have propagated
resource "time_sleep" "cname_and_txt_propagated" {
  create_duration = "60s" # 60 seconds always seems to work with CloudFlare

  depends_on = [cloudflare_dns_record.app_cname, cloudflare_dns_record.app_txt]

  triggers = {
    # changes to any of these would trigger a new wait
    # (this time_sleep resource would be recreated)
    targetfqdn                    = cloudflare_dns_record.app_cname.content
    sourcefqdn                    = var.app_domain_name
    custom_domain_verification_id = local.custom_domain_verification_id
  }
}

# Initialize a custom domain binding in the ingress of the app
# We can do it now, but couldn't when we created the app, because
# now the DNS records with CloudFlare would have propagated. Those
# would be validated by Azure when it creates the binding.
resource "azapi_resource_action" "custom_domain_binding_initialize" {
  depends_on = [time_sleep.cname_and_txt_propagated]

  type        = "Microsoft.App/containerApps@2023-05-01"
  resource_id = azurerm_container_app.app.id
  method      = "PATCH"
  body = {
    properties = {
      configuration = {
        ingress = {
          customDomains = [
            {
              bindingType = "Disabled",
              name        = var.app_domain_name,
            }
          ]
        }
      }
    }
  }
}

# azurerm can't create a managed TLS certificate - 
# see https://github.com/hashicorp/terraform-provider-azurerm/issues/21866
#
# Hence, instead of using azurerm provider the following resources are 
# created using AzAPI provider to make directy API calls to Azure.
resource "azapi_resource" "managed_certificate" {

  # Can only create a cert when DNS record have propagated.
  # I think (but am not sure) that in addition, custom domain binding
  # should also have been created on the app.
  depends_on = [azapi_resource_action.custom_domain_binding_initialize, time_sleep.cname_and_txt_propagated]
  type       = "Microsoft.App/managedEnvironments/managedCertificates@2023-05-01"
  name       = "${lower(var.app-environment-name)}-${lower(var.app-name)}-cert"
  parent_id  = azurerm_container_app_environment.app.id
  location   = azurerm_resource_group.app.location

  body = {
    properties = {
      subjectName             = var.app_domain_name
      domainControlValidation = "CNAME"
    }
  }

  response_export_values = ["*"]
}


# update the already-create custom domani binding in the app's ingress
# with the certificate and make the binding enabled.
resource "azapi_update_resource" "custom_domain_binding_create" {
  type        = "Microsoft.App/containerApps@2023-05-01"
  resource_id = azurerm_container_app.app.id


  body = {
    properties = {
      configuration = {
        ingress = {
          customDomains = [
            {
              bindingType   = "SniEnabled",
              name          = var.app_domain_name,
              certificateId = azapi_resource.managed_certificate.output.id
            }
          ]
        }
      }
    }
  }
}

# The azapiupdate_resource that creates custom binding above works
# during create and update phases of the lifecycle. 
# However, it does nothing during destroy. This leads to a problem
# when destroying the managed cert with the error that the cert 
# is in use in a custom binding (which has not beeen destroyed).
#
# This resource does nothing during update and, depending on setting
# of 'when' argument, works eother during create, or during destroy.
# We have set it to durn during destroy so it destroys the 
# custom domain binding, so that the managed cert can 
# then be destroyed.
resource "azapi_resource_action" "custom_domain_binding_destroy" {
  type = "Microsoft.App/containerApps@2023-05-01"

  # following line also makes this resource a dependent 
  # on the custom_domain_binding_create resource.
  # This resource itself would do nothing during create however, the 
  # dependency just means on destroy it would run - and destoy  the
  # custom domain - before destroy is called on the managed cert.
  resource_id = azapi_update_resource.custom_domain_binding_create.resource_id

  # It seems `action` just gets appended to the URL obtained by
  # appending `resource_id` to the base url for the `type`
  # this gives us URLs for actions on some resources like 
  # `/start` on a Web App in an App Service Plan.
  # WE DON't WANT TO USE IT HERE
  #
  #action                 = ""


  # default for this resource is POST, unlike for the
  # azapi_update_resource for which it seems to be PATCH
  # from my Fiddler investigations
  method = "PATCH"

  response_export_values = ["*"]


  body = {
    properties = {
      configuration = {
        ingress = {
          customDomains = [] # ensures the custom domain would be deleted
        }
      }
    }
  }

  when = "destroy"
}

# TODO: Upadate this comment

# we want requests to the app proxied through CloudFlare
# This is why we added all the ip_restriction blocks 
# to the ingress to allow trafix only from CloudFlare's
# set of stable IPs
#
# HOWEVER, if we set proxied=true on the CNAME record
# then during creation of the managed certificate,
# CNAME verification would fail:
#  RESPONSE 400: 400 Bad Request
#│ ERROR CODE: FailedCnameValidation
#
# Therefore we set proxied=false when creating CNAME record.
#
# Having created managed cert  and updated binding,
# we now set proxied true with this one-time REST call
# (made at the time of creation of this resource only)
#
# We did set this change to `proxied` to be ignored in lifecycle
# block of the CNAME resource so that on subsequent 
# `terraform apply`, Terraform wouldn't try to set it back to false
# as part of its drift detection.
#
# The particular resource we are using below is a one-time REST
# call, done during create only. But if the underlying DNS 
# record change, then managed cert would need to be recreated
# which means proxied would need to set to false again on the
# CNAME record, then wait for managed cert and custom domain binding
# re-creation, then again  set proxied=true.
resource "restful_operation" "turn_on_proxied_in_cname_record" {
  depends_on = [azapi_update_resource.custom_domain_binding_create, azapi_resource.managed_certificate]

  lifecycle {
    replace_triggered_by = [cloudflare_dns_record.app_cname, cloudflare_dns_record.app_txt]
  }

  provider = restful.cloudflare

  path   = "/zones/${cloudflare_dns_record.app_cname.zone_id}/dns_records/${cloudflare_dns_record.app_cname.id}"
  method = "PATCH"
  body   = { "proxied" : true }

  # I think we can also poll for retry. See resource
  # documentation in terraform registry (under
  # magodo/restful provider)
}
