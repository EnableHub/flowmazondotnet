# --- Neon Infrastructure Setup ---

resource "neon_project" "flowmazon_project" {
  name                      = var.neon_project_name
  org_id                    = var.neon_org_id
  history_retention_seconds = 86400
  branch {
    name = var.neon_branch_name
  }

}

resource "neon_role" "owner_role" {
  project_id = neon_project.flowmazon_project.id
  branch_id  = neon_project.flowmazon_project.default_branch_id
  name       = var.neon_owner_role
  # Password will be auto-generated by Neon and available in neon_role.owner_role.password
}

resource "neon_role" "app_role" {
  project_id = neon_project.flowmazon_project.id
  branch_id  = neon_project.flowmazon_project.default_branch_id
  name       = var.neon_app_role
  # Password will be auto-generated by Neon and available in neon_role.app_role.password
}

resource "neon_database" "flowmazon_db" {
  project_id = neon_project.flowmazon_project.id
  branch_id  = neon_project.flowmazon_project.default_branch_id
  name       = var.neon_database_name
  owner_name = neon_role.owner_role.name # Assign ownership to the neon_owner_role
}

# --- PostgreSQL Permissions Setup ---

# It is discouraged to put provider configuration 
# in a child module but in this case it made sense to
# do so as it is using a lot of values that are generated
# during creation of above database resources.

# The provider version/declaration is still in the calling/
# root module though.

# I have aliased the provider block  to try and keep it 
# encapsulated.
provider "postgresql" {

  # Alias for clarity if multiple pg provider configs exist
  # USE RANDOM NAME IF FURTHER UNIQUENESS REQUIRED
  alias           = "db_owner_connection"
  host            = neon_project.flowmazon_project.database_host
  port            = 5432
  database        = neon_database.flowmazon_db.name
  username        = neon_role.owner_role.name     # Authenticate as the owner role
  password        = neon_role.owner_role.password # Use the owner role's auto-generated password
  sslmode         = "require"                     # Neon requires SSL
  connect_timeout = 15
  # superuser = false # neon_owner_role is not a superuser by default
}

# Grant CONNECT to the database for the app role
resource "postgresql_grant" "app_connect" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  object_type = "database"
  privileges  = ["CONNECT"]
}

# Grant USAGE on the public schema for the app role
resource "postgresql_grant" "app_schema_usage" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "schema"
  privileges  = ["USAGE"]
  depends_on  = [postgresql_grant.app_connect]
}

# Grant DML on existing tables in public schema for the app role
resource "postgresql_grant" "app_tables_dml_existing" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "table" # Applies to all tables in the schema
  privileges  = ["SELECT", "INSERT", "UPDATE", "DELETE"]
  depends_on  = [postgresql_grant.app_connect]
}

# Grant DML on future tables created by the owner role in public schema for the app role
resource "postgresql_default_privileges" "app_tables_dml_future" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  owner       = neon_role.owner_role.name
  schema      = "public"
  object_type = "table"
  privileges  = ["SELECT", "INSERT", "UPDATE", "DELETE"]
  depends_on  = [postgresql_grant.app_tables_dml_existing]

}

# Grant USAGE, SELECT on existing sequences in public schema for the app role
resource "postgresql_grant" "app_sequences_usage_select_existing" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "sequence" # Applies to all sequences in the schema
  privileges  = ["USAGE", "SELECT"]
  depends_on  = [postgresql_grant.app_schema_usage]
}

# Grant USAGE, SELECT on future sequences created by the owner role in public schema for the app role
resource "postgresql_default_privileges" "app_sequences_usage_select_future" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  owner       = neon_role.owner_role.name
  schema      = "public"
  object_type = "sequence"
  privileges  = ["USAGE", "SELECT"]
  depends_on  = [postgresql_grant.app_sequences_usage_select_existing]

}

# NOW Put the connection string into key vault as a 
# secret give read permission on this to the user-assigned
# managed identity whose name is provided


resource "azurerm_key_vault_secret" "connstr_for_api" {
  name = var.vault_secretname_for_connectionstring

  key_vault_id = var.key_vault_id

  value = "Server=${neon_project.flowmazon_project.database_host};Port=5432;Database=${neon_database.flowmazon_db.name};User Id=${neon_role.app_role.name};Password=${neon_role.app_role.password}"

}

# NOW assign read permission on the connection string secret
# to the supplied user-asigned managed identity.

# Access Policies aer a legacy authorization model in Azure Key Vault
# So using Azure RBAC which is now the recommendation
# RBAC for Vault also allows key/secret/certificate-level access control
# role and scope chosen based on this page and app requirements:
# https://learn.microsoft.com/en-us/azure/key-vault/general/rbac-guide?tabs=azure-cli
resource "azurerm_role_assignment" "connection_string" {
  scope                = var.key_vault_id
  role_definition_name = "Key Vault Secrets User"
  principal_id         = var.managed_identity_for_secret_principal_id

}

# Create secrets and variables in Github Environment

resource "github_actions_environment_secret" "psql_owner_connection_string" {
  repository      = var.repository_for_secrets_and_variables
  environment     = var.environmentname_for_secrets_and_variables
  secret_name     = var.secretname_for_psql_owner_connectionstring
  plaintext_value = "postgresql://${var.neon_owner_role}:${neon_role.owner_role.password}@${neon_project.flowmazon_project.database_host}/${neon_database.flowmazon_db.name}?sslmode=require&channel_binding=require"
}

# Store owner and app user passwords seprately from 
# the conenction strings stored above. These are needed
# by subsequent Terraform workspaces/GitHub Actions workflows
# to create connection strings for branches.
# (hence why we stored them in GitHub Environment secrets
# and not in key vault)
resource "github_actions_environment_secret" "owner_role_password" {
  repository      = var.repository_for_secrets_and_variables
  environment     = var.environmentname_for_secrets_and_variables
  secret_name     = var.secretname_for_neon_owner_role_password
  plaintext_value = neon_role.owner_role.password
}

resource "github_actions_environment_secret" "app_role_password" {
  repository      = var.repository_for_secrets_and_variables
  environment     = var.environmentname_for_secrets_and_variables
  secret_name     = var.secretname_for_neon_app_role_password
  plaintext_value = neon_role.app_role.password
}


# other secrets to be stored pertaining to the created
# database and Neon DB project
resource "github_actions_environment_secret" "neon_project_default_branch_id" {
  repository      = var.repository_for_secrets_and_variables
  environment     = var.environmentname_for_secrets_and_variables
  secret_name     = var.secretname_for_neon_project_default_branch_id
  plaintext_value = neon_project.flowmazon_project.default_branch_id
}

resource "github_actions_environment_secret" "neon_project_id" {
  repository      = var.repository_for_secrets_and_variables
  environment     = var.environmentname_for_secrets_and_variables
  secret_name     = var.secretname_for_neon_project_id
  plaintext_value = neon_project.flowmazon_project.id
}



