# --- Neon Infrastructure Setup ---

resource "neon_project" "flowmazon_project" {
  name                      = var.neon_project_name
  org_id                    = var.neon_org_id
  history_retention_seconds = 86400
  branch {
    name = var.neon_branch_name
  }

}


resource "neon_role" "owner_role" {
  project_id = neon_project.flowmazon_project.id
  branch_id  = neon_project.flowmazon_project.default_branch_id
  name       = var.neon_owner_role
  # Password will be auto-generated by Neon and available in neon_role.owner_role.password
}

resource "neon_role" "app_role" {
  project_id = neon_project.flowmazon_project.id
  branch_id  = neon_project.flowmazon_project.default_branch_id
  name       = var.neon_app_role
  # Password will be auto-generated by Neon and available in neon_role.app_role.password
}

resource "neon_database" "flowmazon_db" {
  project_id = neon_project.flowmazon_project.id
  branch_id  = neon_project.flowmazon_project.default_branch_id
  name       = var.neon_database_name
  owner_name = neon_role.owner_role.name # Assign ownership to the neon_owner_role
}

# --- PostgreSQL Permissions Setup ---

# It is discouraged to put provider configuration 
# in a child module but in this case it made sense to
# do so as it is using a lot of values that are generated
# during creation of above database resources.

# The provider version/declaration is still in the calling/
# root module though.

# I have aliased the provider block  to try and keep it 
# encapsulated.
provider "postgresql" {

  # Alias for clarity if multiple pg provider configs exist
  # USE RANDOM NAME IF FURTHER UNIQUENESS REQUIRED
  alias           = "postgresql_provider_for_the_only_NeonDB_database_in_the_current_workspace"
  host            = neon_project.flowmazon_project.database_host
  port            = 5432
  database        = neon_database.flowmazon_db.name
  username        = neon_role.owner_role.name     # Authenticate as the owner role
  password        = neon_role.owner_role.password # Use the owner role's auto-generated password
  sslmode         = "require"                     # Neon requires SSL
  connect_timeout = 15
  # superuser = false # neon_owner_role is not a superuser by default
}

# Grant CONNECT to the database for the app role
resource "postgresql_grant" "app_connect" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  object_type = "database"
  privileges  = ["CONNECT"]
}

# Grant USAGE on the public schema for the app role
resource "postgresql_grant" "app_schema_usage" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "schema"
  privileges  = ["USAGE"]
  depends_on  = [postgresql_grant.app_connect]
}

# Grant DML on existing tables in public schema for the app role
resource "postgresql_grant" "app_tables_dml_existing" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "table" # Applies to all tables in the schema
  privileges  = ["SELECT", "INSERT", "UPDATE", "DELETE"]
  depends_on  = [postgresql_grant.app_connect]
}

# Grant DML on future tables created by the owner role in public schema for the app role
resource "postgresql_default_privileges" "app_tables_dml_future" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  owner       = neon_role.owner_role.name
  schema      = "public"
  object_type = "table"
  privileges  = ["SELECT", "INSERT", "UPDATE", "DELETE"]
  depends_on  = [postgresql_grant.app_tables_dml_existing]

}

# Grant USAGE, SELECT on existing sequences in public schema for the app role
resource "postgresql_grant" "app_sequences_usage_select_existing" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "sequence" # Applies to all sequences in the schema
  privileges  = ["USAGE", "SELECT"]
  depends_on  = [postgresql_grant.app_schema_usage]
}

# Grant USAGE, SELECT on future sequences created by the owner role in public schema for the app role
resource "postgresql_default_privileges" "app_sequences_usage_select_future" {
  provider    = postgresql.db_owner_connection
  database    = neon_database.flowmazon_db.name
  role        = neon_role.app_role.name
  owner       = neon_role.owner_role.name
  schema      = "public"
  object_type = "sequence"
  privileges  = ["USAGE", "SELECT"]
  depends_on  = [postgresql_grant.app_sequences_usage_select_existing]

}

# NOW Put the connection string into key vault as a 
# secret give read permission on this to the user-assigned
# managed identity whose name is provided


data "azurerm_key_vault" "app" {
  name                = var.vault_name
  resource_group_name = var.vault_resource_group_name
}

resource "azurerm_key_vault_secret" "connstr_for_api" {
  name = var.vault_secretname_for_connectionstring

  key_vault_id = azurerm_key_vault.vault.id

  value = "Server=${neon_project.flowmazon_project.database_host};Port=5432;Database=${neon_database.flowmazon_db.name};User Id=${neon_role.app_role.name};Password=${neon_role.app_role.password}"

}

# NOW assign read permission on the connection string secret
# to the supplied user-asigned managed identity.

data "azurerm_user_assigned_identity" "connection_string" {
  name                = var.managed_identity_for_secret
  resource_group_name = var.managed_identity_for_secret_resource_group_name
}

# Access Policies aer a legacy authorization model in Azure Key Vault
# So using Azure RBAC which is now the recommendation
# RBAC for Vault also allows key/secret/certificate-level access control
# role and scope chosen based on this page and app requirements:
# https://learn.microsoft.com/en-us/azure/key-vault/general/rbac-guide?tabs=azure-cli
resource "azurerm_role_assignment" "connection_string" {
  scope                = azurerm_key_vault.vault.id
  role_definition_name = "Key Vault Secrets User"
  principal_id         = azurerm_user_assigned_identity.connection_string.principal_id

}


