
resource "neon_branch" "new_branch" {
  project_id = var.neon_source_branch_id
  name       = var.neon_new_branch_name
  parent_id  = var.neon_project_id
}

# We need to create a neon_endpoint for the new branch
# in order to get a connection string to read/write to it.
# There can only be one read/write endpoint (but multiple
# read-only ones). See this link for details:
#
# https://neon.com/docs/reference/terraform#managing-endpoints

resource "neon_endpoint" "new_branch" {
  project_id = var.neon_project_id
  branch_id  = neon_branch.new_branch.id
  type       = "read_write" # "read_write" or "read_only"
  # autoscaling_limit_min_cu = 0.25
  # autoscaling_limit_max_cu = 0.5
  # suspend_timeout_seconds  = 600
  # Optional: Enable connection pooling
  # pooler_enabled = true
}

# PostgreSQL Permissions Setup does not need to be done 
# again as the two users created and the permissions
# assigned to app user on the source branch of the database
# would carry over to the branch we just created.
# HOWEVER, this branch's db is going to be the db for a new
# environment and so we want a new set of credentials that
# are confined to that environment

# 
resource "neon_role" "owner_role" {
  project_id = var.neon_project_id
  branch_id  = neon_branch.new_branch.id
  name       = var.neon_owner_role
  # Password will be auto-generated by Neon and available in neon_role.owner_role.password
}

resource "neon_role" "app_role" {
  project_id = var.neon_project_id
  branch_id  = neon_branch.new_branch.id
  name       = var.neon_app_role
  # Password will be auto-generated by Neon and available in neon_role.app_role.password
}

# --- PostgreSQL Permissions Setup ---

# It is discouraged to put provider configuration 
# in a child module but in this case it made sense to
# do so as it is using a lot of values that are generated
# during creation of above database resources.

# The provider version/declaration is still in the calling/
# root module though.

# I have aliased the provider block  to try and keep it 
# encapsulated.
provider "postgresql" {

  # Alias for clarity if multiple pg provider configs exist
  # USE RANDOM NAME IF FURTHER UNIQUENESS REQUIRED
  alias           = "db_owner_connection"
  host            = neon_endpoint.new_branch.host
  port            = 5432
  database        = var.neon_database_name
  username        = neon_role.owner_role.name     # Authenticate as the owner role
  password        = neon_role.owner_role.password # Use the owner role's auto-generated password
  sslmode         = "require"                     # Neon requires SSL
  connect_timeout = 15
  # superuser = false # neon_owner_role is not a superuser by default
}

# Grant CONNECT to the database for the app role
resource "postgresql_grant" "app_connect" {
  provider    = postgresql.db_owner_connection
  database    = var.neon_database_name
  role        = neon_role.app_role.name
  object_type = "database"
  privileges  = ["CONNECT"]
}

# Grant USAGE on the public schema for the app role
resource "postgresql_grant" "app_schema_usage" {
  provider    = postgresql.db_owner_connection
  database    = var.neon_database_name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "schema"
  privileges  = ["USAGE"]
  depends_on  = [postgresql_grant.app_connect]
}

# Grant DML on existing tables in public schema for the app role
resource "postgresql_grant" "app_tables_dml_existing" {
  provider    = postgresql.db_owner_connection
  database    = var.neon_database_name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "table" # Applies to all tables in the schema
  privileges  = ["SELECT", "INSERT", "UPDATE", "DELETE"]
  depends_on  = [postgresql_grant.app_connect]
}

# Grant DML on future tables created by the owner role in public schema for the app role
resource "postgresql_default_privileges" "app_tables_dml_future" {
  provider    = postgresql.db_owner_connection
  database    = var.neon_database_name
  role        = neon_role.app_role.name
  owner       = neon_role.owner_role.name
  schema      = "public"
  object_type = "table"
  privileges  = ["SELECT", "INSERT", "UPDATE", "DELETE"]
  depends_on  = [postgresql_grant.app_tables_dml_existing]

}

# Grant USAGE, SELECT on existing sequences in public schema for the app role
resource "postgresql_grant" "app_sequences_usage_select_existing" {
  provider    = postgresql.db_owner_connection
  database    = var.neon_database_name
  role        = neon_role.app_role.name
  schema      = "public"
  object_type = "sequence" # Applies to all sequences in the schema
  privileges  = ["USAGE", "SELECT"]
  depends_on  = [postgresql_grant.app_schema_usage]
}

# Grant USAGE, SELECT on future sequences created by the owner role in public schema for the app role
resource "postgresql_default_privileges" "app_sequences_usage_select_future" {
  provider    = postgresql.db_owner_connection
  database    = var.neon_database_name
  role        = neon_role.app_role.name
  owner       = neon_role.owner_role.name
  schema      = "public"
  object_type = "sequence"
  privileges  = ["USAGE", "SELECT"]
  depends_on  = [postgresql_grant.app_sequences_usage_select_existing]

}




# NOW Put the connection string into key vault as a secret
resource "azurerm_key_vault_secret" "connstr_for_api" {
  name = var.vault_secretname_for_connectionstring

  key_vault_id = var.key_vault_id

  value = "Server=${neon_endpoint.new_branch.host};Port=5432;Database=${neon_database.flowmazon_db.name};User Id=${neon_role.app_role.name};Password=${neon_role.app_role.password}"

}

# NOW assign read permission on the connection string secret
# to the supplied user-asigned managed identity.

# Access Policies aer a legacy authorization model in Azure Key Vault
# So using Azure RBAC which is now the recommendation
# RBAC for Vault also allows key/secret/certificate-level access control
# role and scope chosen based on this page and app requirements:
# https://learn.microsoft.com/en-us/azure/key-vault/general/rbac-guide?tabs=azure-cli
resource "azurerm_role_assignment" "connection_string" {
  scope                = var.key_vault_id
  role_definition_name = "Key Vault Secrets User"
  principal_id         = var.managed_identity_for_secret_principal_id

}


