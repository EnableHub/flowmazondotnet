using System.Text;
using Microsoft.Extensions.Logging;

namespace flowmazonapi.IntegrationTests;

/// <summary>
/// An ILogger that is meant to be passed
/// in to .WithLogger chained call when configuring
/// new ImageFromDockerfileBuilder()
/// </summary>
/// <remarks>
/// <para>
/// When an image fails to build or a container doesn't start up
/// in test setup code written using Testcontainers,
/// we need to pass an ILogger in to 
/// <c>new ImageFromDockerfileBuilder().WithLogger(...)</c>.
/// Then any logs generated by the <c>docker build</c> command
/// that is internally executed by the image builder returned
/// by <c>ImageFromDockerfileBuilder.Build()</c> will be written
/// by Testcontainers to this <c>ILogger</c> (they will not be
/// sent to the console unlike if you executed <c>docker build</c>
/// on the terminal yourself).
/// </para>
/// <para>
/// At some point during test execution, we can call 
/// <c>TestLogger.AccumulatedLogs.Tostring()</c> to get 
/// the logs and pass them to <c>WriteLine</c> method of 
/// XUnit's <c>ITestOutputHelper</c> interface that 
/// is injected in the test class's constructor. This would
/// write out those logs to Console once test execution has
/// finished.
/// </para>
/// <para>
/// <example>
/// If image is being built in a fixture, use this class
/// as follows:
/// <list type="number">
/// <item>
/// Create and expose an instance of it as a public property 
/// in the fixture:
/// <code>
/// public class APITestFixture : IAsyncLifetime
/// {
///    public readonly TestLogger Logger = new TestLogger();
/// <code>
/// </item>
/// <item>
/// Pass it to <c>.WithLogger()</c> in code to build
/// container in <c>IAsyncLifetime.InitializeAsync</c>
/// method in the fixture class:
/// <code>
/// public async Task InitializeAsync()
/// {
///  var futureImage = new ImageFromDockerfileBuilder()
///  .WithDockerfileDirectory(
///     CommonDirectoryPath.GetSolutionDirectory(), string.Empty)
///  .WithDockerfile("Dockerfile")
///  .WithLogger(Logger)
/// </code>
/// </item>
/// <item>
/// In test class's constructor, take in <c>ITestOutputHelper</c>
/// alongside the fixture class (it is not possible to get an 
/// <c>ITestOutputHelper</c> in a fixture class, we can only
/// get it injected by XUnit in a test class). Primary consructor
/// shown in the snippet below:
/// <code>
/// public class ProductTests(APITestFixture fixture,
///     ITestOutputHelper testOutput) : IClassFixture<APITestFixture>
/// {
/// </code>
/// </item>
/// <item>
/// At some point, whether in the test class constructor or in a test,
/// write out the logs:
/// <code>
/// testOutput.WriteLine(fixture.Logger.AccumulatedLogs.ToString());
/// </code>
/// </item>
/// </list>
/// </example>
/// </para>
/// </remarks>
public sealed class TestLogger()
         : ILogger
{

    public StringBuilder AccumulatedLogs = new StringBuilder();

    public IDisposable? BeginScope<TState>(TState state) where TState : notnull => default!;

    public bool IsEnabled(LogLevel logLevel) =>
        true;

    public void Log<TState>(
        LogLevel logLevel,
        EventId eventId,
        TState state,
        Exception? exception,
        Func<TState, Exception?, string> formatter)
    {
        if (!IsEnabled(logLevel))
        {
            return;
        }


        AccumulatedLogs.AppendLine($"[{eventId.Id,2}: {logLevel,-12}]");

        AccumulatedLogs.AppendLine($"{formatter(state, exception)}");


    }
}